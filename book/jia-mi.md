## HTTPS

HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密

1. 对数据进行加密 并建立一个信息安全通道 来保证传输过程中的数据安全、
2. 对网站服务器进行真实身份认证

## 存在背景

##### HTTP缺点

* HTTP使用明文 内容可能被窃听
* 无法证明报文的完整性
* 不验证通信方的身份

##### HTTPS

* 数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密匙
* 数据完整性：内容传输经过完整性校验
* 身份认证： 第三方无法伪造服务器（客户端）身份

## 如何解决？

HTTPS协议是HTTP通信接口部分用SSL和TLS协议代替了而已

通常HTTP直接和TCP通信 使用SSL 则演变成**HTTP**先和**SSL**通信 再和**TCP**通信

![](/assets/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32322f313637643438626337376565363966383f773d35363126683d32393726663d706e6726733d313430313839.png)

#### 1 解决内容可能被窃听的问题

##### 对称加密

加密和解密通用一个密匙 在怎么安全把密匙转交给对方是一个问题

**非对称加密**

一把叫做私有密匙 一把叫做公开密匙（可以发布）用公匙加密信息 用私匙解密

**缺点：**

* 公匙是公开的 所以针对私匙加密的信息 黑客截获后可以用公匙进行解密
* 公匙不包含服务器的信息 所以无法确保服务器身份的合法性 存在中间人攻击的风险 服务器发送给客户端的公匙可能在传送过程中被中间人截获并篡改
* 数据加密解密过程需要消耗一定的时间 降低了数据传输效率

**对称加密+非对称加密（HTTPS采用这种方式）**

对称加密解密效率快 非对称好处是可以使传送的内容不被破解 结合起来利用优势 **在交换密匙环节使用非对称加密方式（防止密匙泄漏） 之后的建立通信交换报文阶段则使用对称加密方式（解密效率高）**

#### 2 解决报文可能被篡改---数字签名

传输过程中 报文可能不会被破解 但可能被篡改 校验数字签名

* 确定消息确实是由发送方签名并发出来的 因为别人假冒不了发送方的签名
* 数字签名能确定消息的完整性 证明数据是否被篡改过

**数字签名生成**：取部分内容 通过**hash算法** 生成**消息摘要** 再用**私匙加密** 生成数字签名 随报文一同发送

**数字签名验证**：用发送者的**公匙解密摘要信息** 然后用HASH函数对收到的原文**产生一个摘要信息** 进行**对比**

如何传送安全的公匙 并证明是发送者的 引入 **证书颁发机构**

#### 3 解决通信方身份可能被伪装的问题---数字证书

数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。

![](/assets/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32332f313637643934373132613563656230653f773d34313726683d33313326663d706e6726733d3937373635.png)

##### **数字证书认证**的业务流程：

* 服务器的运营人员向第三方机构CA提交公钥、组织信息、个人信息\(域名\)等信息并申请认证;
* CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;
* 如信息审核通过，CA会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。 其中签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA的私钥对信息摘要进行加密，密文即签名;
* 客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件;
* 客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。
* 客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任CA的证书信息\(包含公钥\)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。

## HTTPS工作流程

* Client发起一个HTTPS（比如`https://juejin.im/user/5a9a9cdcf265da238b7d771c`）的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。

* Server把事先配置好的公钥证书（public key certificate）返回给客户端。

* Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。

* Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。

* Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。
* Server使用对称密钥加密“明文内容A”，发送给Client。
* Client使用对称密钥解密响应的密文，得到“明文内容A”。
* Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。

## HTTP和HTTPS的区别

* HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页;
* HTTPS需要用到SSL证书，而HTTP不用;
* HTTPS标准端口443，HTTP标准端口80;
* HTTPS基于传输层，HTTP基于应用层;
* HTTPS在浏览器显示绿色安全锁，HTTP没有显示;



