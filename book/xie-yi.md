> 原文链接：[https://segmentfault.com/a/1190000018401534?spm=a2c4e.10696291.0.0.7b6619a4jEEU2T](https://segmentfault.com/a/1190000018401534?spm=a2c4e.10696291.0.0.7b6619a4jEEU2T)

### Http协议 （超文本传输协议）

应用层 建立在Tcp协议之上

### HHTTP1.x 的缺点

* ##### 连接无法复用

每次请求都经历三次握手和慢启动

* ##### **Head-Of-Line Blocking（HOLB）**

一系列包因为第一个包被阻塞

* ##### 协议开销大

header 里面携带的内容过大

* ##### 安全因素

明文传输

#### SPDY协议

### HTTP2.0

基于SPDY3 专注于性能

##### 二进制传输

将请求和响应数据分割为帧 并且采用二进制编码

* 流：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（1、2…N）；

* 消息：是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。

* 帧：HTTP 2.0 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流，承载着特定类型的数据，如 HTTP 首部、负荷，等等

同域名下所有通信都在单个连接上完成 可以承载任意数量的双向数据流 每个流以消息的形式发送 消息又由一个或者多个帧组成 多个帧之间可以乱序发送 根据帧首的流标识可以重新组装

##### 多路复用

解决了浏览器限制同一个域名下的请求数量问题 因为只用一个连接  基于二进制分帧 性能有了很大的提升

* 同一个域名只占用一个连接 消除多个tcp连接带来的延时和内存消耗
* 并行交错的发送多个请求 互不干扰
* 并行交错发送多个响应 互不影响
* 每个请求都可以带31bit的优先值 0代表最高级 数值越大 等级越低 有了优先级 客户端和浏览器就可以在处理不同流的时候采取不同的策略 以最优的方式发送流、消息和帧

##### header 压缩

http使用文本形式传输header 携带cookie 每次都会很大

减少资源消耗 提升性能 采取压缩策略：

* 在客户端和服务端使用“首部表”来跟踪和存储之前法送的键值对 对于相同的数据 不再重复发送
* 在http2连接存续期间始终存在 由客户端和服务端共同渐进的更新
* 每个新的首部键值对要么被追加到末尾 要么替换表中的值

第二个请求只需要发送差异数据 这样可以减少冗余数据 降低开销

##### server push

服务端能通过push的方式客户端需要的内容预先推送过去

客户端有权利选择接受 或者拒绝 如果已经缓存过可以发送REST\_STREAM帧来拒收 主动推送也遵守同源策略

### HTTP3

因为之前的协议是基于TCP协议的 所以存在一个很大的问题 一旦单连接中的一个流出现丢包的问题 会导致整个TCP的流全部重传！！！

所以新的协议是基于UDP协议的QUIC协议

#### QUIC的新功能

##### O-RTT

* 传输层ORTT就能建立连接
* 加密层ORTT就能建立加密连接

http完全握手建联过程需要三个RTT 就算会话复用也要至少两个2个RTT 但是QUIC 由于建立在UDP基础上 又实现了ORTT的安全握手 所以大部分情况下0个RTT就能实现数据发送 在实现前向加密的基础上 ORTT的成功率比TLS的会话记录单要高

##### 多路复用

虽然http2实现了多路复用 但TCP协议中就是没有这个功能的 但QUIC原生就实现了这个功能 并且传输的单个数据流可以保证有序交付且不会影响其他数据流

同一条QUIC连接上可以创建多个stream 来发送多个http请求 但是QUIC是基于UCDP的 所以多个stream之间没有依赖 所以其中一个stream丢包 不影响其他stram

在移动端的表现也更好 以为TCP是基于IP和端口识别的 但是QUIC是通过ID识别的 只要ID不变 就能迅速重连

##### 加密认证的报文

TCP协议的头部没有经过任何加密和认证 但QUIC除了个别报文比如PUBILC\_RESET和CHLO所有报文都是经过认证的 报文body都是经过加密的

##### 向前纠错机制

每个数据包除了本身的内容之外 还包括了部分其他数据包的数据 因此 少量的丢包可以通过其他包的冗余数据直接组装而不用重传 牺牲了每个数据包可以发送的数据上线 减少了丢包重传的消耗 （但也仅限于少量丢包）

