> 原文链接：[https://github.com/ljianshu/Blog/issues/23](https://github.com/ljianshu/Blog/issues/23)

## 缓存位置

#### Service Worker

* 运行在浏览器背后的独立线程 
* 传输协议必须为**https** 因为涉及请求拦截 所以必须适应https协议来保障安全 
* 可以**自由控制**缓存哪些文件、如何匹配缓存、如何读取缓存 并且缓存是持续性的

实现缓存 先**注册**service worker 然后**监听**到install事件以后就可以缓存需要的文件 下次请求进行拦截 如果命中 直接读取

没有命中 调用fetch函数获取数据 根据**缓存查找优先级**去查找数据 但是不管是从memory cache 还是从网络请求中获取的数据 都会显示是从service worker中获取的数据

#### Memory Cache

* **内存**中的缓存 主要包含当前页面中已经抓取到的资源 
* 比磁盘快 但缓存持续性很短 会随着进程的释放而释放 
* 缓存资源perloader相关指令 一边解析js/css文件 一百年网络请求下一个资源
* 内存缓存 并不关心http缓存头cache-control中是什么值 同时资源匹配也并非仅仅对URL做匹配  可能还会对content-type cors等其他特征做验证

#### Disk Cache

* **硬盘**缓存 速度慢点 但是什么都能存 比内存缓存生在容量和存储时效性
* 根据header判断是否缓存 是否可以直接使用 哪些已经过期
* 跨站点情况下 相同地址的资源一旦被缓存 就不用再次请求

使用情况倾向：对于大文件倾向于硬盘 当前系统内存使用率高 也会优先存储硬盘

#### Push Cache

* **推送**缓存 HTTP2中的内容 以上三种都没有命中的时候使用
* 只在会话中存在 时间短暂 chorme只有五分钟左右 也并非严格执行HTTP头中的缓存指令
* 所有资源都能推送和被缓存
* 可以推送 no-cache 和 no-store 的资源
* 一旦连接被关闭，Push Cache 就被释放
* 多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。
* Push Cache 中的缓存只能被使用一次
* 浏览器可以拒绝接受已经存在的资源推送
* 你可以给其他域名推送资源

如果以上四种缓存都没有命中 那么可以发起请求获取资源 选择缓存策略 **强缓存**和**协商缓存** 通过设置header来实现

