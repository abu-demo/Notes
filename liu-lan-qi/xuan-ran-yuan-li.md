> 原文地址：[https://github.com/ljianshu/Blog/issues/51](https://github.com/ljianshu/Blog/issues/51)

## 页面加载过程

* 浏览器根据 DNS 服务器得到域名的 IP 地址
* 向这个 IP 的机器发送 HTTP 请求
* 服务器收到、处理并返回 HTTP 请求
* 浏览器得到返回内容

## 浏览器渲染过程

#### 1 解析三个东西

##### 1 HTML/SVG/XHTML 

* 浏览器从磁盘或网络读取HTML的**原始字节**，并根据文件的指定编码（例如 UTF-8）将它们转换成**字符串**。
* 将字符串转换成**Token** 
* 生成节点对象并构建**DOM** 一边生成Token一边消耗Token生成节点对象

##### 2 CSSOM

浏览器得递归DOM树生成 CSS Rule Tree 相当复杂和有性能问题 所以DOM树要小 尽量使用id和class

##### 3 JavaScript脚本 

如果在构建DOM过程中出现**&lt;script&gt;**标签 会**停止GUI渲染线程** 执行**JS引擎线程** 互斥关系。但因为JS也能更改CSS 所以 一旦中途插入JS 浏览器会先**下载和构建CSSOM** 完成之后再执行**JS脚本** 最后再**恢复DOM**的构建

如果不想影响可以设置**JS延迟加载**：

* **defer**：异步引入 页面构建完毕执行  顺序加载
* **async**：异步引入JavaScript 加载好便开始执行（阻塞GUI引擎） 无序加载

#### 2 解析完成 通过DOM Tree 和 CSS Rule Tree 来构造Rendering Tree

* Rendering Tree 渲染树并不等同于DOM树，渲染树只会包括**需要显示的节点和这些节点的样式信息。**
* CSS 的 Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个Element（也就是每个Frame）。
* 然后，计算每个Frame 的位置，这又叫layout和reflow过程。

#### 3 调用操作系统的Native GUI的API绘制

浏览器生成渲染树之后 就会根据渲染树进行布局（回流 重排）自动重排

##### 重排和重绘

* 重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。
* 回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）

##### 操作DOM慢

当我们用 JS 去操作 DOM 时，本质上是 **JS 引擎**和**渲染引擎**之间进行了“跨界交流”。这个“跨界交流”的实现并不简单，它依赖了桥接接口作为“桥梁”，过桥要收费 次数多了就会产生明显的性能问题

